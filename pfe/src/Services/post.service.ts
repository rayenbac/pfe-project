import { IPostRepository } from '../Interfaces/post/IPostRepository'
import { IPost } from '../Interfaces/post/IPost'
import { IResult } from '../Interfaces/IResult'
import { injectable } from 'inversify'
import { Post } from '../Models/post'
import "reflect-metadata";
import { Document, Types } from 'mongoose'

// business layer
@injectable() // decorator
class PostService implements IPostRepository {

    //get all posts
    async getPosts() { // asynchronous func.
        try {
            const posts = await Post.find({}).populate('author', 'firstName lastName email profileImage').sort({ createdAt: -1 });
            return posts
        } catch (error) {
            console.log(error)
        }
    }

    //get a single post
    async getPost(id: string) {
        try {
            const post = await Post.findById({ _id: id }).populate('author', 'firstName lastName email profileImage');
            if (!post) {
                return '404'
            }
                return post
            
        } catch (error) {
            console.log(error)
            return '404';
        }
    }
    //create a post
    async createPost(data: any) {
        try {
            const newPost = await Post.create(data);
            // If author is provided, add post to user's posts array
            if (data.author) {
                const User = require('../Models/user').User;
                await User.findByIdAndUpdate(
                    data.author,
                    { $push: { posts: newPost._id } },
                    { new: true }
                );
            }
            return newPost;
        } catch (error) {
            console.log(error);
        }
    }

    //update a post
    async updatePost(id: string, data: any) {
        try {
            //pass the id of the object you want to update
            //data is for the new body you are updating the old one with
            //new:true, so the dats being returned, is the update one
            const posts = await Post.findByIdAndUpdate({ _id: id }, data, { new: true })
            if (!posts) {
                return "post not available"
            }
            return posts
        } catch (error) {
            console.log(error)
        }
    }

    //delete a post by using the find by id and delete 
    async deletePost(id: string) {
        try {
            const post = await Post.findByIdAndDelete(id)
            if (!post) {
                return 'post not available'
            }
        } catch (error) {
            console.log(error)
        }
    }

    async patchUpdate(id: string, data: any) {
        try {
            const updatedOne = await Post.updateOne(
                { _id: id },
                { $set: data }
            );
            return updatedOne
        } catch (err) {
            console.log(err);
        }

    }

    async getChunk(queryPool: {
        sortType: string,
        pageIndex: number,
        orderBy: 1 | -1,
        filter: {
            likes: {
                $gte: number;
                $lte: number;
            };
        }
    }, limit: number = 5) {
        //const pagination = new Pagination(queryPool.pageIndex, limit); // pass page-index and limit

        let items: (Document<unknown, any, IPost> & IPost & {
            _id: Types.ObjectId;
        })[]

/*         if(queryPool.filter){
            items = await Post.find(queryPool.filter)
            .sort({ [queryPool.sortType]: queryPool.orderBy }) // id is automatically generated by mongodb so posts requested according to createdAt
            .skip((queryPool.pageIndex - 1) * limit) // first post, get posts by index
            .limit(limit) // last post
        }else{ */
            items = await Post.find(/* queryPool.filter */)
            .sort({ [queryPool.sortType]: queryPool.orderBy }) // id is automatically generated by mongodb so posts requested according to createdAt
            .skip((queryPool.pageIndex - 1) * limit) // first post, get posts by index
            .limit(limit) // last post
        

        const result: IResult = {
            total: await Post.countDocuments(),
            limit: limit,
            posts: items
        }
        return result
    }

    async search(q: string, queryPool: {
        sortType: string,
        pageIndex: number,
        orderBy: 1 | -1
    }, limit: number = 2) {
        try {
            console.log(q)
            // that's a exact string match solution, mongoDB doesn't support partial match search but can be found solutions...
            const answer = await Post.find({ $text: { $search: q, $caseSensitive: true } })
                 .sort({[queryPool.sortType]: queryPool.orderBy })
                .skip((queryPool.pageIndex - 1) * limit)
                .limit(limit)

            const result: IResult = {
                total: answer.length,
                limit: limit,
                posts: answer
            }
            return result
        } catch (error) { console.log(error) }
    }

    // Add a review to a post
    async addReview(postId: string, review: any) {
        try {
            const post = await Post.findById(postId);
            if (!post) return null;
            
            // Initialize reviews array if it doesn't exist
            post.reviews = post.reviews || [];
            
            // Add the review
            post.reviews.push(review);
            
            // Save the post
            const savedPost = await post.save();
            
            // Get the newly added review (it will be the last one with an _id)
            if (savedPost.reviews && savedPost.reviews.length > 0) {
                const newReview = savedPost.reviews[savedPost.reviews.length - 1];
                return { post: savedPost, review: newReview };
            }
            
            return { post: savedPost, review: null };
        } catch (error) {
            console.log(error);
            return null;
        }
    }
}

export { PostService } 
